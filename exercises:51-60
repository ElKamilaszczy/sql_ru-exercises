-- Exercise 51 - Ships
Find the names of the ships with the largest number of guns among all ships having the same displacement (including ships in the Outcomes table).

with all_ships(name, displacement, numGuns) as(
select s.name, c.displacement, c.numGuns from classes c join ships s on s.class = c.class
union
select o.ship, c.displacement, c.numGuns from classes c inner join outcomes o on o.ship = c.class
)
, rns as (
select name, displacement, numGuns, dense_rank() over(partition by displacement order by numGuns desc) as dr from all_ships
where numGuns is not null and displacement is not null
)
select name from rns where dr = 1;

Firstly - we are talking about ship names - class being standalone (which doesnt have any ships) cannot be considered as a valid ship. Secondly I've used dense_rank function on UNIONED dataset to actually retrieve largest numGuns within the same displacement. Also i needed to take into consideration fact, that numGuns and displacement can be NULL

-- Exercise 52 -- Ships
Determine the names of all ships in the Ships table that can be a Japanese battleship having at least nine main guns with a caliber of less than 19 inches and a displacement of not more than 65 000 tons. 

select s.name from ships s inner join classes c on
c.class = s.class
where country = 'Japan'
and type = 'bb'
and isnull(numGuns, 9) >= 9 and isnull(bore, 18) < 19
and isnull(displacement, 1) <= 65000 

What I have to consider are these words: "CAN BE" -> the author meant that if a value is null, that this ship is considered as "could be". This solution is actually hardcoded. Below is a better version:

select s.name from ships s inner join classes c on
c.class = s.class
where country = 'Japan'
and type = 'bb'
and (numGuns is null or numGuns >=9)
and (bore is null or bore < 19)
and (displacement is null or displacement<= 65000) 

